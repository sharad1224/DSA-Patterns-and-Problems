<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Serialize & Deserialize Binary Tree - CodeDSA</title>
    <link rel="stylesheet" href="../../CSS/AllProblems.css" />
    <link rel="stylesheet" href="../../CSS/breadcrumb.css" />
    <link rel="stylesheet" href="../../CSS/snake.css" />
  </head>
  <body>
    <!-- Navbar -->
    <nav class="navbar">
      <div class="logo">CodeDSA</div>
      <div class="nav-right">
        <ul class="nav-links">
          <li><a href="../../index.html">Home</a></li>
          <li><a href="../../about.html">About</a></li>
          <li><a href="../../contact.html">Contact</a></li>
        </ul>
        <button id="snakeToggle" class="snake-btn">
          <span style="margin-left: 20px">Snake Cursor</span>
        </button>
      </div>
    </nav>

    <!-- Breadcrumb Navigation -->
    <div class="breadcrumb-container">
      <nav aria-label="breadcrumb">
        <ol class="breadcrumb">
          <li class="breadcrumb-item"><a href="../../index.html">Home</a></li>
          <li class="breadcrumb-item">
            <a href="../binaryTrees.html">Binary Trees</a>
          </li>
          <li class="breadcrumb-item active" aria-current="page">
            Serialize & Deserialize Binary Tree
          </li>
        </ol>
      </nav>
    </div>

    <main>
      <h1>Serialize & Deserialize Binary Tree</h1>

      <!-- Problem Statement -->
      <section class="problem-section">
        <h2>Problem Statement</h2>
        <p>
          Design an algorithm to serialize a binary tree into a string and
          deserialize it back to the original tree structure.
        </p>
        <p><strong>Example:</strong></p>
        <pre class="pseudo-code">
Input:    1
         / \
        2   3
           / \
          4   5

Serialized: "1,2,NULL,NULL,3,4,NULL,NULL,5,NULL,NULL"
Deserialize(serialized) â†’ original tree
      </pre
        >
      </section>

      <!-- Approaches -->
      <section class="approach-section">
        <h2>Approach 1: Preorder Traversal with NULL markers</h2>
        <p>
          <strong>Explanation:</strong> Serialize tree recursively using
          preorder traversal, marking NULLs for missing children. Deserialize
          using same traversal.
        </p>
        <p><strong>Time Complexity:</strong> O(n)</p>
        <p><strong>Space Complexity:</strong> O(n)</p>
        <pre class="pseudo-code">
function serialize(root):
    if root == NULL: return "NULL,"
    return str(root.val)+"," + serialize(root.left) + serialize(root.right)

function deserialize(data):
    list = data.split(",")
    return helper(list)

function helper(list):
    val = list.pop(0)
    if val == "NULL": return NULL
    node = TreeNode(val)
    node.left = helper(list)
    node.right = helper(list)
    return node
      </pre
        >
      </section>

      <section class="approach-section">
        <h2>Approach 2: Level Order (BFS) Traversal</h2>
        <p>
          <strong>Explanation:</strong> Use a queue for BFS. Serialize level by
          level including NULLs. Deserialize using the queue to reconstruct tree
          level by level.
        </p>
        <p><strong>Time Complexity:</strong> O(n)</p>
        <p><strong>Space Complexity:</strong> O(n)</p>
        <pre class="pseudo-code">
function serialize(root):
    if root == NULL: return ""
    queue = [root]
    result = []
    while queue:
        node = queue.pop(0)
        if node:
            result.append(str(node.val))
            queue.append(node.left)
            queue.append(node.right)
        else:
            result.append("NULL")
    return ",".join(result)

function deserialize(data):
    if data == "": return NULL
    vals = data.split(",")
    root = TreeNode(vals[0])
    queue = [root]
    i = 1
    while queue:
        node = queue.pop(0)
        if vals[i] != "NULL":
            node.left = TreeNode(vals[i])
            queue.append(node.left)
        i += 1
        if vals[i] != "NULL":
            node.right = TreeNode(vals[i])
            queue.append(node.right)
        i += 1
    return root
      </pre
        >
      </section>

      <section class="approach-section">
        <h2>Approach 3: DFS with Stack (Iterative Serialization)</h2>
        <p>
          <strong>Explanation:</strong> Use a stack for iterative preorder
          traversal. Push NULL markers for missing children. Deserialize using
          list iteration.
        </p>
        <p><strong>Time Complexity:</strong> O(n)</p>
        <p><strong>Space Complexity:</strong> O(n)</p>
        <pre class="pseudo-code">
function serialize(root):
    stack = [root]
    result = []
    while stack:
        node = stack.pop()
        if node:
            result.append(str(node.val))
            stack.push(node.right)
            stack.push(node.left)
        else:
            result.append("NULL")
    return ",".join(result)

function deserialize(data):
    list = data.split(",")
    index = 0
    function helper():
        nonlocal index
        if list[index] == "NULL":
            index += 1
            return NULL
        node = TreeNode(list[index])
        index += 1
        node.left = helper()
        node.right = helper()
        return node
    return helper()
      </pre
        >
      </section>
    </main>

    <!-- Footer -->
    <footer>
      <p>&copy; 2025 Mrunalini Pachpute. All rights reserved.</p>
    </footer>

    <script src="../../index.js"></script>
    <script src="../../JS/problemTracker.js"></script>
  </body>
</html>
